# Guardrail

> Smart account permissions and spending guardrails for AI agents on Ethereum.

Guardrail lets you create dedicated smart accounts for AI bots — completely separated from your personal wallet — with built-in spending limits enforced on-chain.

## What Guardrail Does

Guardrail solves the problem of giving AI bots autonomous on-chain access without risking your personal wallet. Instead of sharing your private key with a bot, Guardrail:

1. Generates a fresh keypair for each bot (client-side, never stored)
2. Deploys an ERC-4337 smart account with the generated address as signer
3. Enforces spending policies on-chain via PermissionEnforcer
4. Provides a validation API for pre-flight action checks
5. Logs every action for auditing and compliance

## Core Concepts

### Bot Signer Generation
Generate a dedicated keypair for your bot during agent creation. The private key is shown once and never stored on any server. Your personal wallet stays completely separate from the bot's wallet. The bot gets its own smart account that you fund with only what it needs.

### Smart Accounts (ERC-4337)
Each bot operates through an ERC-4337 smart account. The smart account calls PermissionEnforcer during validateUserOp — transactions that violate policy revert before execution. This means even if the bot is compromised, it physically cannot exceed the spending limits you set.

### Policies
Policies define what a bot can do:
- Actions: swap, transfer, stake, etc.
- Assets: specific tokens, protocols, chains
- Constraints: max value per transaction, daily volume cap, transaction count limit
- Duration: valid from/until timestamps

### Permissions
Permissions link an agent to a policy. When you grant a permission, the agent can perform actions within that policy's rules. Permissions can be minted on-chain as ERC-8004 tokens.

### Enforcement Tiers
- Advisory (EOA): Off-chain validation API with monitoring and alerts. Cannot prevent on-chain execution.
- Enforced (Smart Account): On-chain + off-chain enforcement. Unauthorized transactions revert automatically.

## Fee Structure

Guardrail operates as protocol-level infrastructure with enforced on-chain fees via the GuardrailFeeManager contract.

### Account Creation Fee
- **Amount:** $10 USD equivalent in ETH (one-time)
- **Enforced in:** AgentAccountFactory.createAccount (payable)
- **Conversion:** Uses PriceOracle.getEthUsdPrice() for real-time ETH/USD rate
- **Formula:** `creationFeeUsd * 1e20 / ethUsdPrice` (creationFeeUsd is 6 decimals, ethUsdPrice is 8 decimals)
- **Example:** At ETH = $2,000 → creation fee = 0.005 ETH

### Transfer Fee (Outbound Only)
- **Rate:** 10 basis points (0.10%)
- **Cap:** $100 USD equivalent per transaction
- **Applied on:** Every `execute()` or `executeBatch()` call with `value > 0`
- **Not charged on:** Inbound deposits (receive()), zero-value calls (ERC-20 via calldata)
- **Formula:** `fee = value * transferFeeBps / 10000`, capped at `usdToWei(transferFeeCapUsd)`

| Transfer | Fee |
|----------|-----|
| $1,000 | $1.00 |
| $10,000 | $10.00 |
| $100,000 | $100.00 (cap) |
| $2,000,000 | $100.00 (cap) |

## Smart Contracts (Base Mainnet — Chain ID 8453)

### IdentityRegistry
- **Address:** 0xc1fa477f991C74Cc665E605fC74f0e2B795b5104
- **Purpose:** ERC-8004 agent identity registration
- **Key functions:**
  - `registerAgent(bytes32 agentId, string metadata)` — Register a new agent
  - `getAgent(bytes32 agentId) → (address owner, string metadata, bool active, uint256 registeredAt)` — Get agent details
  - `isAgentActive(bytes32 agentId) → bool` — Check if agent is active

### PolicyRegistry
- **Address:** 0x92cd41e6a4aA13072CeBCda8830d48f269F058c4
- **Purpose:** On-chain policy and permission storage
- **Key functions:**
  - `createPolicy(bytes32 contentHash) → bytes32 policyId` — Create a new policy
  - `grantPermission(bytes32 policyId, bytes32 agentId, uint256 validFrom, uint256 validUntil) → bytes32 permissionId` — Grant permission
  - `revokePermission(bytes32 permissionId)` — Revoke a permission
  - `isPermissionValid(bytes32 permissionId) → bool` — Check if permission is still valid
  - `getAgentPermissions(bytes32 agentId) → bytes32[]` — Get all permissions for an agent

### PermissionEnforcer
- **Address:** 0xbF63Fa97cfBba99647B410f205730d63d831061c
- **Purpose:** Action validation with constraints (value limits, volume caps, tx count, token/protocol/chain allowlists)
- **Key functions:**
  - `validateAction(bytes32 agentId, bytes32 actionHash, bytes actionData) → ValidationResult` — Validate an action against permissions
  - `setConstraints(bytes32 permissionId, uint256 maxValuePerTx, uint256 maxDailyVolume, uint256 maxTxCount, bytes32[] allowedActions, address[] allowedTokens, address[] allowedProtocols, uint256[] allowedChains)` — Set permission constraints
  - `recordUsage(bytes32 agentId, bytes32 actionHash, uint256 value)` — Record usage after action
  - `getRemainingQuota(bytes32 permissionId, bytes32 agentId, bytes32 actionHash) → (uint256 remainingVolume, uint256 remainingTxCount)` — Check remaining quota
  - `setPriceOracle(address _priceOracle)` — Set price oracle for cross-token normalization

### PriceOracle
- **Address:** 0xf3c8c6BDc54C60EDaE6AE84Ef05B123597C355B3
- **Purpose:** Chainlink-powered ETH/USD and token price feeds for USD conversion
- **Key functions:**
  - `getEthUsdPrice() → uint256` — Returns ETH/USD price (8 decimals, e.g. 200000000000 = $2000)
  - `getEthValue(address token, uint256 amount) → uint256` — Convert token amount to ETH equivalent
  - `setTokenFeed(address token, address feed)` — Configure Chainlink feed for a token
  - `STALENESS_THRESHOLD` — 1 hour; reverts if price feed is stale

### GuardrailFeeManager
- **Address:** 0xD1B7Bd65F2aB60ff84CdDF48f306a599b01d293A
- **Purpose:** Centralized fee configuration for all accounts and the factory
- **Why separate contract:** AgentSmartAccount uses immutable state. If fee config were inline, rates would be baked into each account's bytecode and could never change. FeeManager lets all accounts read current config at runtime.
- **Key functions:**
  - `getCreationFeeWei() → uint256` — Convert creationFeeUsd to wei using PriceOracle
  - `calculateTransferFee(uint256 value) → uint256` — Calculate transfer fee in wei (with cap)
  - `feeCollector() → address` — Treasury address receiving all fees
  - `creationFeeUsd() → uint256` — Creation fee in 6-decimal USD (10_000000 = $10)
  - `transferFeeBps() → uint256` — Transfer fee in basis points (10 = 0.10%)
  - `transferFeeCapUsd() → uint256` — Transfer fee cap in 6-decimal USD (100_000000 = $100)
  - `setFeeCollector(address)` — Update fee collector (owner only)
  - `setCreationFee(uint256)` — Update creation fee (owner only)
  - `setTransferFee(uint256 bps, uint256 capUsd)` — Update transfer fee (owner only)
  - `setPriceOracle(address)` — Update price oracle (owner only)

### AgentAccountFactory
- **Address:** 0xCE621A324A8cb40FD424EB0D41286A97f6a6c91C
- **Purpose:** CREATE2 factory for deterministic smart account deployment with creation fee
- **Key functions:**
  - `createAccount(address owner, bytes32 agentId, bytes32 salt) payable → address` — Deploy smart account (requires creation fee as msg.value; idempotent — refunds on duplicate)
  - `getAddress(address owner, bytes32 agentId, bytes32 salt) → address` — Compute address without deploying
  - `getCreationFee() → uint256` — Get current creation fee in wei

### AgentSmartAccount
- **Purpose:** ERC-4337 IAccount implementation with permission enforcement and transfer fees
- **Deployed by:** AgentAccountFactory (not directly)
- **Key functions:**
  - `execute(address target, uint256 value, bytes data)` — Execute a call (deducts transfer fee on value > 0)
  - `executeBatch(address[] targets, uint256[] values, bytes[] datas)` — Execute batch (fee per sub-call with value > 0)
  - `validateUserOp(UserOperation userOp, bytes32 userOpHash, uint256 missingAccountFunds) → uint256` — ERC-4337 validation (verifies signature + enforces permissions)
  - `owner() → address` — Account owner (signer)
  - `agentId() → bytes32` — Bound agent identifier
  - `entryPoint() → address` — ERC-4337 EntryPoint address
  - `receive()` — Accept inbound ETH (no fee)

### Contract Interaction Flow
```
1. Factory.createAccount{value: fee}(owner, agentId, salt)
   ├── Deploys AgentSmartAccount(owner, agentId, enforcer, entryPoint, feeManager)
   └── Sends creation fee to feeManager.feeCollector()

2. Account.execute(target, value, data)  [called by owner or via EntryPoint]
   ├── feeManager.calculateTransferFee(value) → fee
   ├── Send fee to feeManager.feeCollector()
   └── Send (value - fee) to target

3. EntryPoint.handleOps(userOps)  [ERC-4337 flow]
   ├── Account.validateUserOp(userOp, hash, funds)
   │   ├── Verify ECDSA signature (owner)
   │   └── enforcer.validateAction(agentId, actionHash, actionData)
   │       └── Check constraints (value, volume, tokens, protocols, chains)
   └── Account.execute(target, value, data)  [if validation passes]
```

### Other Contract Details
- EntryPoint (v0.6): 0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789
- Chain ID: 8453 (Base Mainnet)

## Smart Contracts (Sepolia Testnet — Chain ID 11155111)

| Contract | Address |
|----------|---------|
| IdentityRegistry | 0xc1fa477f991C74Cc665E605fC74f0e2B795b5104 |
| PolicyRegistry | 0x92cd41e6a4aA13072CeBCda8830d48f269F058c4 |
| PermissionEnforcer | 0x94991827135fbd0E681B3db51699e4988a7752f1 |
| PriceOracle | 0x052cDddba3C55A63F5e48F9e5bC6b70604Db93b8 |
| GuardrailFeeManager | 0x0f77fdD1AFCe0597339dD340E738CE3dC9A5CC12 |
| AgentAccountFactory | 0xA831229B58C05d5bA9ac109f3B29e268A0e5F41E |
| EntryPoint (v0.6) | 0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789 |

## API Reference

Base URL: https://your-backend-url

### Authentication
- API Key: `X-API-Key: YOUR_API_KEY` (recommended for bots)
- JWT: `Authorization: Bearer YOUR_TOKEN` (for dashboard sessions)

### Validation
- `POST /api/v1/validate` — Check if an action is allowed before executing
- `POST /api/v1/validate/simulate` — Simulate without recording
- `POST /api/v1/validate/batch` — Validate multiple actions

### Agents
- `POST /api/v1/agents` — Register an agent (wallet_type: eoa | smart_account)
- `GET /api/v1/agents` — List agents (includes signer_type: wallet | generated)
- `GET /api/v1/agents/{id}` — Get agent details
- `POST /api/v1/agents/{id}/deploy-smart-account` — Deploy smart account (signer_type: wallet | generated)
- `GET /api/v1/agents/{id}/smart-account` — Get smart account details
- `POST /api/v1/agents/{id}/upgrade-to-smart-account` — Upgrade EOA to smart account (one-way)
- `POST /api/v1/agents/{id}/register-onchain` — Register on ERC-8004 identity registry

### Policies
- `POST /api/v1/policies` — Create policy
- `GET /api/v1/policies` — List policies
- `GET /api/v1/policies/{id}` — Get policy details
- `PUT /api/v1/policies/{id}` — Update policy
- `POST /api/v1/policies/{id}/activate` — Activate policy
- `POST /api/v1/policies/{id}/revoke` — Revoke policy

### Permissions
- `POST /api/v1/permissions` — Grant permission (link agent to policy)
- `GET /api/v1/permissions` — List permissions
- `POST /api/v1/permissions/{id}/mint` — Mint permission on-chain
- `DELETE /api/v1/permissions/{id}` — Revoke permission

### Audit
- `GET /api/v1/audit` — Query audit logs (filter by event_type, agent_id, date range)
- `GET /api/v1/audit/export` — Export logs as JSON or CSV

## Validate API Example

```
POST /api/v1/validate
X-API-Key: YOUR_API_KEY
Content-Type: application/json

{
  "agent_id": "your-agent-uuid",
  "action": {
    "type": "swap",
    "token": "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
    "amount": "1000",
    "protocol": "uniswap-v3"
  }
}

Response (allowed):
{
  "allowed": true,
  "permission_id": "...",
  "policy_id": "...",
  "constraints": {
    "maxValuePerTx": "5000",
    "maxDailyVolume": "50000"
  },
  "enforcement_level": "enforced",
  "wallet_type": "smart_account",
  "onchain_enforced": true,
  "request_id": "..."
}

Response (denied):
{
  "allowed": false,
  "reason": "exceeds maximum transaction value",
  "request_id": "..."
}
```

## Policy Definition Schema

```json
{
  "actions": ["swap", "transfer"],
  "assets": {
    "tokens": ["0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48"],
    "protocols": ["uniswap-v3"],
    "chains": [1, 11155111]
  },
  "constraints": {
    "maxValuePerTx": "5000",
    "maxDailyVolume": "50000",
    "maxTxCount": 100
  },
  "duration": {
    "validFrom": "2024-01-01T00:00:00Z",
    "validUntil": "2024-12-31T23:59:59Z"
  }
}
```

## Technology Stack

- Backend: Go 1.22, Chi router, PostgreSQL (pgx), zerolog
- Frontend: Next.js 15, React 18, Wagmi, RainbowKit, Tailwind CSS
- Contracts: Solidity 0.8.24, Foundry, ERC-8004 + ERC-4337
- Auth: Sign-In with Ethereum (SIWE) + JWT + API keys
- Infrastructure: Railway (backend) + Vercel (frontend) + Base mainnet & Sepolia (contracts)

## Integration Quick Start

1. Connect wallet and sign in at the Guardrail dashboard
2. Register an agent with "Secure Account" + "Generate Bot Signer"
3. Click "Generate Key" then "Register Agent"
4. Download the .env file from the private key reveal dialog
5. Create a policy with spending limits and activate it
6. Grant permission linking the agent to the policy
7. Create an API key in Settings
8. Use the validate API in your bot's code before each on-chain action

## Funding a Smart Account

Send ETH to the smart account address from any wallet. The smart account accepts ETH from any source. Copy the address from the agent card in the dashboard and send ETH via MetaMask or any wallet. No fee is charged on inbound deposits.

## Withdrawing from a Smart Account

Withdrawal method depends on signer type. A transfer fee of 10 bps (0.10%), capped at $100 USD, is deducted from outbound ETH transfers.

### Wallet Signer (Connected Wallet)
Your MetaMask wallet is the smart account owner. Use the Withdraw button in the agent card dropdown menu. The transaction is signed by MetaMask directly.

### Generated Bot Signer
The bot's private key is the smart account owner. Two options:
1. **Dashboard withdrawal:** Click Withdraw in the agent card menu, paste the bot's private key from your .env file. The key signs the transaction client-side in your browser — it is never sent to any server. The key is validated against the bot's signer address and cleared from memory after use.
2. **Bot-initiated withdrawal:** The bot calls `execute(destinationAddress, amount, "0x")` on its smart account contract using its private key.

## Links

- Dashboard: /
- Documentation: /docs
- About: /about
- Skills: /skills/guardrail-smart-accounts.md
